#
# Copyright (C) 2023, Inria
# GRAPHDECO research group, https://team.inria.fr/graphdeco
# All rights reserved.
#
# This software is free for non-commercial, research and evaluation use
# under the terms of the LICENSE.md file.
#
# For inquiries contact  george.drettakis@inria.fr
#

import os
import shutil
from errno import EEXIST
from os import makedirs, path

import matplotlib.pyplot as plt
import numpy as np
import trimesh as tm


def mkdir_p(folder_path):
    # Creates a directory. equivalent to using mkdir -p on the command line
    try:
        makedirs(folder_path)
    except OSError as exc:  # Python >2.5
        if exc.errno == EEXIST and path.isdir(folder_path):
            pass
        else:
            raise


def move(src, dst, overwrite=True):
    if overwrite and os.path.exists(dst):
        if os.path.isfile(dst) or os.path.islink(dst):
            os.remove(dst)
        elif os.path.isdir(dst):
            shutil.rmtree(dst)
    if os.path.isdir(src):
        shutil.copytree(src, dst)
        shutil.rmtree(src)
    else:
        shutil.copy2(src, dst)
        os.remove(src)


def searchForMaxIteration(folder):
    saved_iters = [int(fname.split("_")[-1]) for fname in os.listdir(folder)]
    return max(saved_iters)


def check_gs_model(model_path, saving_iterations, fix_pcd=False, postfix=""):
    folder = "point_cloud_fix_pcd" if fix_pcd else "point_cloud"
    folder = folder + postfix
    p = os.path.join(model_path, folder)
    if not os.path.exists(model_path):
        return False
    if not os.path.exists(p):
        return False
    if len(os.listdir(p)) <= 0:
        return False
    if not searchForMaxIteration(p) == saving_iterations[-1]:
        return False
    else:
        max_iter = searchForMaxIteration(p)
        print(f"Find the model: {p}, iterations: {max_iter}")
        return True


def check(model_path, folder, iterations):
    p = os.path.join(model_path, folder)
    if not os.path.exists(model_path):
        return False
    if not os.path.exists(p):
        return False
    if len(os.listdir(p)) <= 0:
        return False
    if not searchForMaxIteration(p) == iterations:
        return False
    return True


def draw_curve(curve, path, name="loss"):
    x = range(1, len(curve) + 1)
    plt.figure()
    plt.plot(x, curve, label=name)

    plt.xlabel("Training Steps")
    plt.ylabel(name)
    plt.title("{} curve".format(name))

    plt.legend()

    plt.savefig("{}/{}.png".format(path, name))


def write_particles(particles, idx, path, name="", vertex_colors=None):
    if type(particles) == np.ndarray:
        numpy_array = particles
    else:
        numpy_array = particles.cpu().detach().numpy()
    if not os.path.exists(os.path.join(path, "mpm")):
        mkdir_p(os.path.join(path, "mpm"))
    if vertex_colors is None:
        tm.Trimesh(numpy_array).export(os.path.join(path, f"mpm/{name}_{idx}.ply"))
    else:
        tm.Trimesh(numpy_array, vertex_colors=vertex_colors).export(os.path.join(path, f"mpm/{name}_{idx}.ply"))
